<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>천하제일 근성 대회 — Tetris</title>
<style>
  :root{
    /* ── 고정 팔레트 (변경 금지) ───────────────────────── */
    --bg:#0b1020;         /* 전체 배경(짙은 네이비) */
    --panel:#0f1630;      /* 카드 / 캔버스 배경 */
    --line:#1b2548;       /* 경계선/디바이더 */
    --muted:#99a8c7;      /* 묵은 텍스트 */
    --fg:#e7f0ff;         /* 본문 텍스트(옅은 흰) */
    --accent:#49b2ff;     /* 포커스/버튼 */
    --good:#2ecc71;       /* 강조(성공) */
    --warn:#ffcc66;
    --danger:#ff5666;
    --gold:#ffd86b;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family: ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif;
  }
  .wrap{
    max-width:1200px; margin:0 auto; padding:16px;
    display:grid; grid-template-columns: 320px 1fr; gap:16px;
  }
  @media (max-width: 980px){
    .wrap{grid-template-columns: 1fr;}
  }

  /* ── 좌측: 게임 카드 ─────────────────────────────── */
  .card{
    background:var(--panel); border:1px solid var(--line);
    border-radius:14px; padding:14px;
  }
  .canvas-box{ position:relative; }
  canvas{
    display:block; background:#0a1228; border-radius:12px;
    border:1px solid var(--line); margin-bottom:10px;
  }
  .hud{
    display:flex; gap:10px; justify-content:space-between; align-items:center;
    font-size:13px; color:var(--muted);
    border-top:1px dashed rgba(255,255,255,.12); padding-top:10px;
  }
  .hud strong{ color:var(--fg); }

  /* ── 우측: 보드/리스트 영역(지금은 타이틀/테이블 프레임만 유지) ─ */
  .board{
    background:var(--panel); border:1px solid var(--line);
    border-radius:14px; padding:14px;
  }
  .board .tabs{ display:flex; gap:8px; margin-bottom:12px; }
  .chip{
    font-size:12px; padding:6px 10px; border-radius:999px;
    border:1px solid var(--line); color:var(--muted);
    background:transparent; cursor:default;
  }
  .chip.on{ color:var(--fg); border-color:var(--good); box-shadow:0 0 0 1px rgba(46,204,113,.15) inset; }

  table{ width:100%; border-collapse:collapse; }
  th,td{ text-align:left; padding:8px; border-bottom:1px dashed rgba(255,255,255,.08); font-size:14px;}
  th{ color:#cfe2ff; }
  tbody tr:hover{ background-color:rgba(255,255,255,.03); }

  /* ── 버튼 ───────────────────────────────────────── */
  .btn{
    background:linear-gradient(180deg,#1084ff,#0865ff);
    color:#fff; border:none; border-radius:10px;
    padding:10px 14px; cursor:pointer; font-weight:700;
  }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  .btn-ghost{
    background:transparent; border:1px solid var(--line); color:#cfe2ff;
    border-radius:10px; padding:10px 14px; cursor:pointer;
  }
  .note{ font-size:12px; color:var(--muted); }

  /* ── 시작/재시작 오버레이 ───────────────────────── */
  .overlay{
    position:absolute; inset:0; background:rgba(0,0,0,.45);
    display:flex; align-items:center; justify-content:center;
    z-index:10; border-radius:12px;
  }
  .start-box{
    width:min(88%,280px); background:rgba(15,22,48,.95);
    border:1px solid var(--line); border-radius:16px;
    padding:18px; text-align:center; backdrop-filter: blur(4px);
  }
  .start-box h3{ margin:6px 0 12px; }
  .start-box input{
    width:100%; background:#04132f; color:var(--fg); border:1px solid var(--line);
    border-radius:10px; padding:10px 12px; outline:none; margin-bottom:10px;
  }
  .start-box input:focus{ border-color:var(--accent); box-shadow:0 0 0 2px rgba(73,178,255,.18); }
  .start-box .sub{ font-size:12px; color:var(--muted); margin-top:8px; }

  /* ── 모바일 조작키 ─────────────────────────────── */
  .mobile-keys{
    display:none; margin-top:10px; gap:8px; flex-wrap:wrap; justify-content:center;
  }
  .mkey{
    flex:1 1 calc(25% - 8px);
    min-width:62px; text-align:center;
    background:#0c234a; border:1px solid var(--line); color:#cfe2ff;
    border-radius:12px; padding:10px 0; user-select:none;
  }
  .mkey:active{ transform:translateY(1px); background:#0b2a5f; }

  @media (max-width: 768px){
    .mobile-keys{ display:flex; }
  }

  /* 툴팁/상태 ───────────────────────────────────── */
  .status{
    display:inline-flex; align-items:center; gap:6px;
    padding:8px 12px; border-radius:999px; font-size:12px;
    border:1px solid var(--line);
  }
  .status.ok{ color:#d4ffe9; border-color:#244b35; background:#12251b; }
  .status.bad{ color:#ffe1e1; border-color:#4b2424; background:#251212; }
</style>
</head>
<body>

<div class="wrap">
  <!-- left: game -->
  <section class="card">
    <div class="canvas-box">
      <canvas id="game" width="300" height="600" aria-label="Tetris board"></canvas>

      <!-- 시작/재시작 오버레이 -->
      <div id="overlay" class="overlay" hidden>
        <div class="start-box">
          <h3 id="ov-title">시작 / Restart</h3>
          <p class="sub">닉네임을 입력하고 시작하세요.</p>
          <input id="nickname" type="text" placeholder="닉네임 / Nickname (2자 이상)" maxlength="16" />
          <button id="btnStart" class="btn" disabled>시작</button>
          <div class="sub">조작키: ← → 이동 · ↑ 회전 · ↓ 소프트드롭, Space 하드드롭</div>
        </div>
      </div>
    </div>

    <div class="mobile-keys" aria-hidden="false">
      <div class="mkey" data-key="ArrowLeft">⬅️</div>
      <div class="mkey" data-key="ArrowUp">⬆️</div>
      <div class="mkey" data-key="ArrowRight">➡️</div>
      <div class="mkey" data-key="ArrowDown">⬇️</div>
      <div class="mkey" data-key="Space">DROP</div>
    </div>

    <div class="hud">
      <div>점수 <strong id="score">0</strong></div>
      <div>라인 <strong id="lines">0</strong></div>
      <div>레벨 <strong id="level">1</strong></div>
    </div>
  </section>

  <!-- right: list/board frame (향후 랭킹 연동 자리 유지) -->
  <section class="board">
    <div class="tabs">
      <span class="chip on">실시간 업데이트 (Firebase RTDB)</span>
      <span class="chip">점수 저장 완료 / Saved</span>
      <span class="chip">ALL</span>
      <span class="chip">This Week</span>
      <span class="chip">This Month</span>
      <span class="chip">KR</span>
    </div>

    <table>
      <thead>
        <tr><th>#</th><th>닉네임 / Nickname</th><th>국가 / Country</th><th>점수 / Score</th></tr>
      </thead>
      <tbody id="tbody"><tr><td colspan="4" class="note">랭킹 연동 전 — 게임 정상 동작 확인용 레이아웃</td></tr></tbody>
    </table>
  </section>
</div>

<script>
/* =========================================================
   TETRIS — Classic Scoring + Mobile Keys + Overlay Start
   ========================================================= */

(() => {
  const COLS = 10, ROWS = 20, BLOCK = 30; // canvas 300x600
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // HUD
  const elScore = document.getElementById('score');
  const elLines = document.getElementById('lines');
  const elLevel = document.getElementById('level');

  // Overlay
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ov-title');
  const nickname = document.getElementById('nickname');
  const btnStart = document.getElementById('btnStart');

  // Classic scoring table (per line clear), multiplied by (level+1)
  // index = cleared lines (0..4)
  const LINE_TABLE = [0, 40, 100, 300, 1200];

  // Board (0=empty, >0 = color index)
  let board;

  // Game state
  let score = 0, lines = 0, level = 0;  // 화면엔 level+1 로 노출
  let dropCounter = 0, dropInterval = 1000; // ms
  let lastTime = 0;
  let running = false;
  let nick = '';

  // Piece definitions
  const TETROMINOES = {
    'T': [[0,1,0],[1,1,1],[0,0,0]],
    'O': [[1,1],[1,1]],
    'L': [[1,0,0],[1,1,1],[0,0,0]],
    'J': [[0,0,1],[1,1,1],[0,0,0]],
    'Z': [[1,1,0],[0,1,1],[0,0,0]],
    'S': [[0,1,1],[1,1,0],[0,0,0]],
    'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  };
  const TYPES = Object.keys(TETROMINOES);

  // Colors (팔레트 유지)
  const COLORS = {
    0:'#0a1228',
    1:'#49b2ff', // I
    2:'#ffd86b', // O
    3:'#2ecc71', // S
    4:'#ff5666', // Z
    5:'#ff8ad6', // T
    6:'#8ad1ff', // J
    7:'#ffa552', // L
  };

  // Current piece
  let piece = null;

  function createBoard(){
    return Array.from({length: ROWS}, () => Array(COLS).fill(0));
  }

  function resetGame(){
    board = createBoard();
    score = 0; lines = 0; level = 0;
    updateHUD();
    spawn(); // 첫 스폰이 충돌이면 그 즉시 Game Over 처리됨
    dropCounter = 0;
    lastTime = 0;
    running = true;
  }

  function spawn(){
    const type = TYPES[Math.floor(Math.random()*TYPES.length)];
    const matrix = TETROMINOES[type].map(r => r.slice());
    piece = {
      x: ((COLS/2)|0) - ((matrix[0].length/2)|0),
      y: 0,
      matrix,
      color: typeToColor(type)
    };
    // 스폰 즉시 충돌 체크 -> Game Over
    if (collide(board, piece)){
      gameOver();
      return;
    }
  }

  function typeToColor(t){
    // t: I,O,S,Z,T,J,L -> 1..7
    const map = { I:1, O:2, S:3, Z:4, T:5, J:6, L:7 };
    return map[t];
  }

  function collide(board, p){
    const m = p.matrix;
    for (let y=0; y<m.length; y++){
      for (let x=0; x<m[y].length; x++){
        if (m[y][x]){
          const ny = p.y + y;
          const nx = p.x + x;
          if (ny < 0 || ny >= ROWS || nx < 0 || nx >= COLS || board[ny][nx]){
            return true;
          }
        }
      }
    }
    return false;
  }

  function merge(board, p){
    const m = p.matrix;
    for (let y=0; y<m.length; y++){
      for (let x=0; x<m[y].length; x++){
        if (m[y][x]){
          board[p.y+y][p.x+x] = p.color;
        }
      }
    }
  }

  function rotate(matrix, dir=1){
    // transpose
    for (let y=0; y<matrix.length; y++){
      for (let x=0; x<y; x++){
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    // reverse rows
    if (dir > 0){
      matrix.forEach(row => row.reverse());
    }else{
      matrix.reverse();
    }
    return matrix;
  }

  function tryRotate(dir=1){
    const clone = piece.matrix.map(r => r.slice());
    rotate(clone, dir);
    const oldX = piece.x;
    let offset = 0;
    while (collide(board, { ...piece, matrix: clone, x: piece.x + offset })){
      offset = offset ? -(offset + (offset>0?1:-1)) : 1;
      if (Math.abs(offset) > clone[0].length) return; // 실패
    }
    piece.matrix = clone;
    piece.x += offset;
  }

  function softDrop(){
    piece.y++;
    if (collide(board, piece)){
      piece.y--;
      lockPiece();
      return false;
    }else{
      // soft drop 가산
      score += 1;
      updateHUD();
      return true;
    }
  }

  function hardDrop(){
    let dropped = 0;
    while (!collide(board, piece)){
      piece.y++;
      dropped++;
    }
    piece.y--; dropped--;
    // hard drop 가산(칸당 +2)
    score += Math.max(0, dropped*2);
    lockPiece();
  }

  function move(dir){
    piece.x += dir;
    if (collide(board, piece)){
      piece.x -= dir;
    }
  }

  function lockPiece(){
    merge(board, piece);
    // 블록 고정 보너스
    score += (level * 10);

    const cleared = sweep();
    if (cleared > 0){
      // 라인 점수: LINE_TABLE[cleared] * (level+1)
      score += LINE_TABLE[cleared] * (level+1);
    }

    // 레벨업 규칙: 10라인마다 +1
    if (Math.floor(lines/10) > level){
      level = Math.floor(lines/10);
      setSpeedByLevel();
    }

    updateHUD();
    spawn(); // 다음 조각
  }

  function sweep(){
    let cleared = 0;
    outer: for (let y=ROWS-1; y>=0; y--){
      for (let x=0; x<COLS; x++){
        if (!board[y][x]) continue outer;
      }
      // 가득 참 -> 삭제
      const row = board.splice(y,1)[0].fill(0);
      board.unshift(row);
      cleared++; y++; // 같은 y 재검사
    }
    lines += cleared;
    return cleared;
  }

  function setSpeedByLevel(){
    // 클래식 느낌 (대략) — 레벨 올라갈수록 빨라짐
    // 원하면 세밀하게 조정 가능
    const table = [1000, 900, 800, 700, 600, 500, 450, 400, 350, 300, 260, 220, 200, 180, 160, 140, 120, 100, 90, 80];
    dropInterval = table[Math.min(level, table.length-1)];
  }

  function updateHUD(){
    elScore.textContent = score.toLocaleString();
    elLines.textContent = lines;
    elLevel.textContent = (level+1);
  }

  function drawBlock(x,y,colorIndex){
    ctx.fillStyle = COLORS[colorIndex];
    ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
    // 살짝 입체감
    ctx.strokeStyle = 'rgba(0,0,0,.25)';
    ctx.strokeRect(x*BLOCK+.5, y*BLOCK+.5, BLOCK-1, BLOCK-1);
  }

  function draw(){
    // 보드
    for (let y=0; y<ROWS; y++){
      for (let x=0; x<COLS; x++){
        drawBlock(x,y, board[y][x]);
      }
    }
    // current piece
    if (piece){
      const m = piece.matrix;
      for (let y=0; y<m.length; y++){
        for (let x=0; x<m[y].length; x++){
          if (m[y][x]){
            drawBlock(piece.x+x, piece.y+y, piece.color);
          }
        }
      }
    }
  }

  function tick(time=0){
    if (!running) return; // stop
    const delta = time - lastTime;
    lastTime = time;
    dropCounter += delta;
    if (dropCounter > dropInterval){
      dropCounter = 0;
      if (!softDrop()){
        // 이미 lockPiece() 내에서 spawn
      }
    }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    draw();
    requestAnimationFrame(tick);
  }

  function gameOver(){
    running = false;
    showOverlay('GAME OVER — 다시 시작', true);
  }

  function showOverlay(title="시작 / Restart", isRestart=false){
    ovTitle.textContent = title;
    overlay.hidden = false;
    nickname.value = isRestart ? nick : '';
    btnStart.disabled = !(nickname.value.trim().length >= 2);
    nickname.focus();
  }
  function hideOverlay(){
    overlay.hidden = true;
  }

  // ── Controls ──────────────────────────────────────
  function keyHandler(e){
    if (!running) return;
    if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' '].includes(e.key)){
      e.preventDefault();
    }
    switch(e.key){
      case 'ArrowLeft': move(-1); break;
      case 'ArrowRight': move(1); break;
      case 'ArrowDown': softDrop(); break;
      case 'ArrowUp': tryRotate(1); break;
      case ' ': case 'Spacebar': hardDrop(); break;
    }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    draw();
  }
  window.addEventListener('keydown', keyHandler);

  // 모바일 키
  document.querySelectorAll('.mkey').forEach(b=>{
    const k = b.dataset.key;
    const fire = ()=> {
      // overlay 열려있으면 동작 X
      if (!running) return;
      if (k==='ArrowLeft') move(-1);
      else if (k==='ArrowRight') move(1);
      else if (k==='ArrowDown') softDrop();
      else if (k==='ArrowUp') tryRotate(1);
      else if (k==='Space') hardDrop();
      ctx.clearRect(0,0,canvas.width,canvas.height); draw();
    };
    b.addEventListener('touchstart', e=>{ e.preventDefault(); fire(); }, {passive:false});
    b.addEventListener('click', fire);
  });

  // ── Overlay events ────────────────────────────────
  nickname.addEventListener('input', ()=>{
    btnStart.disabled = !(nickname.value.trim().length >= 2);
  });
  btnStart.addEventListener('click', ()=>{
    nick = nickname.value.trim();
    if (nick.length < 2) return;
    hideOverlay();
    resetGame();
    requestAnimationFrame(tick);
  });

  // 초기 표시
  board = createBoard();
  updateHUD();
  showOverlay('시작 / Restart', false);
})();
</script>
</body>
</html>
