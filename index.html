<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>천하제일 근성 대회 — Tetris</title>
<style>
  :root{
    /* ── 고정 팔레트 (변경 금지) ───────────────────────── */
    --bg:#0b1020;         /* 전체 배경(짙은 네이비) */
    --panel:#0f1630;      /* 카드 / 캔버스 배경 */
    --line:#1b2548;       /* 경계선/디바이더 */
    --muted:#99a8c7;      /* 묵은 텍스트 */
    --fg:#e7f0ff;         /* 본문 텍스트(옅은 흰) */
    --accent:#49b2ff;     /* 포커스/버튼 */
    --good:#2ecc71;       /* 강조(성공) */
    --warn:#ffcc66;
    --danger:#ff5666;
    --gold:#ffd86b;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family: ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif;
  }
  .wrap{
    max-width:1200px; margin:0 auto; padding:16px;
    display:grid; grid-template-columns: 320px 1fr; gap:16px;
  }
  @media (max-width: 980px){
    .wrap{grid-template-columns: 1fr;}
  }

  /* ── 좌측: 게임 카드 ─────────────────────────────── */
  .card{
    background:var(--panel); border:1px solid var(--line);
    border-radius:14px; padding:14px;
  }
  .canvas-box{ position:relative; }
  canvas{
    display:block; background:#0a1228; border-radius:12px;
    border:1px solid var(--line); margin-bottom:10px;
  }
  .hud{
    display:flex; gap:10px; justify-content:space-between; align-items:center;
    font-size:13px; color:var(--muted);
    border-top:1px dashed rgba(255,255,255,.12); padding-top:10px;
  }
  .hud strong{ color:var(--fg); }

  /* ── 우측: 보드/리스트 영역(프레임 유지) ─────────── */
  .board{
    background:var(--panel); border:1px solid var(--line);
    border-radius:14px; padding:14px;
  }
  .board .tabs{ display:flex; gap:8px; margin-bottom:12px; }
  .chip{
    font-size:12px; padding:6px 10px; border-radius:999px;
    border:1px solid var(--line); color:var(--muted);
    background:transparent; cursor:default;
  }
  .chip.on{ color:var(--fg); border-color:var(--good); box-shadow:0 0 0 1px rgba(46,204,113,.15) inset; }

  table{ width:100%; border-collapse:collapse; }
  th,td{ text-align:left; padding:8px; border-bottom:1px dashed rgba(255,255,255,.08); font-size:14px;}
  th{ color:#cfe2ff; }
  tbody tr:hover{ background-color:rgba(255,255,255,.03); }

  /* ── 버튼 ───────────────────────────────────────── */
  .btn{
    background:linear-gradient(180deg,#1084ff,#0865ff);
    color:#fff; border:none; border-radius:10px;
    padding:10px 14px; cursor:pointer; font-weight:700;
  }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  .btn-ghost{
    background:transparent; border:1px solid var(--line); color:#cfe2ff;
    border-radius:10px; padding:10px 14px; cursor:pointer;
  }
  .note{ font-size:12px; color:var(--muted); }

  /* ── 시작/게임오버 오버레이 ─────────────────────── */
  .overlay{
    position:absolute; inset:0; background:rgba(0,0,0,.45);
    display:flex; align-items:center; justify-content:center;
    z-index:10; border-radius:12px;
  }
  .overlay[hidden], .overlay.hide{ display:none !important; pointer-events:none !important; }

  .start-box{
    width:min(88%,300px); background:rgba(15,22,48,.95);
    border:1px solid var(--line); border-radius:16px;
    padding:18px; text-align:center; backdrop-filter: blur(4px);
  }
  .start-box h3{ margin:6px 0 12px; }
  .start-box input{
    width:100%; background:#04132f; color:var(--fg); border:1px solid var(--line);
    border-radius:10px; padding:10px 12px; outline:none; margin-bottom:10px;
  }
  .start-box input:focus{ border-color:var(--accent); box-shadow:0 0 0 2px rgba(73,178,255,.18); }
  .start-box .score-line{
    margin:4px 0 10px; font-size:14px; color:var(--gold); display:none;
  }
  .start-box .sub{ font-size:12px; color:var(--muted); margin-top:8px; }

  /* ── 모바일 조작키 ─────────────────────────────── */
  .mobile-keys{
    display:none; margin-top:10px; gap:8px; flex-wrap:wrap; justify-content:center;
  }
  .mobile-keys.show{ display:flex; }
  @media (max-width: 768px){
    .mobile-keys{ display:flex; }
  }
  .mkey{
    flex:1 1 calc(25% - 8px);
    min-width:62px; text-align:center;
    background:#0c234a; border:1px solid var(--line); color:#cfe2ff;
    border-radius:12px; padding:10px 0; user-select:none;
  }
  .mkey:active{ transform:translateY(1px); background:#0b2a5f; }
</style>
</head>
<body>

<div class="wrap">
  <!-- left: game -->
  <section class="card">
    <div class="canvas-box">
      <canvas id="game" width="300" height="600" aria-label="Tetris board"></canvas>

      <!-- 시작/게임오버 오버레이 -->
      <div id="overlay" class="overlay">
        <div class="start-box">
          <h3 id="ov-title">시작 / Restart</h3>
          <p class="sub">닉네임을 입력하고 시작하세요.</p>

          <input id="nickname" type="text" placeholder="닉네임 / Nickname (2자 이상)" maxlength="16" />
          <div id="ov-score" class="score-line">이번 점수 : <strong id="ov-score-val">0</strong></div>

          <button id="btnStart" type="button" class="btn" disabled>게임 시작</button>
          <div class="sub">조작키: ← → 이동 · ↑ 회전 · ↓ 소프트드롭, Space 하드드롭</div>
        </div>
      </div>
    </div>

    <div id="mKeys" class="mobile-keys" aria-hidden="false">
      <div class="mkey" data-key="ArrowLeft">⬅️</div>
      <div class="mkey" data-key="ArrowUp">⬆️</div>
      <div class="mkey" data-key="ArrowRight">➡️</div>
      <div class="mkey" data-key="ArrowDown">⬇️</div>
      <div class="mkey" data-key="Space">DROP</div>
    </div>

    <div class="hud">
      <div>점수 <strong id="score">0</strong></div>
      <div>라인 <strong id="lines">0</strong></div>
      <div>레벨 <strong id="level">1</strong></div>
    </div>
  </section>

  <!-- right: ranking frame (유지) -->
  <section class="board">
    <div class="tabs">
      <span class="chip on">실시간 업데이트 (Firebase RTDB)</span>
      <span class="chip">점수 저장 완료 / Saved</span>
      <span class="chip">ALL</span>
      <span class="chip">This Week</span>
      <span class="chip">This Month</span>
      <span class="chip">KR</span>
    </div>

    <table>
      <thead>
        <tr><th>#</th><th>닉네임 / Nickname</th><th>국가 / Country</th><th>점수 / Score</th></tr>
      </thead>
      <tbody id="tbody"><tr><td colspan="4" class="note">랭킹 연동 전 — 게임 정상 동작 확인용 레이아웃</td></tr></tbody>
    </table>
  </section>
</div>

<script>
/* =========================================================
   TETRIS — Classic Scoring + Mobile Keys + Start/Over Overlay
   ========================================================= */

(() => {
  const COLS = 10, ROWS = 20, BLOCK = 30; // canvas 300x600
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // HUD
  const elScore = document.getElementById('score');
  const elLines = document.getElementById('lines');
  const elLevel = document.getElementById('level');

  // Overlay
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ov-title');
  const nickname = document.getElementById('nickname');
  const btnStart = document.getElementById('btnStart');
  const ovScoreWrap = document.getElementById('ov-score');
  const ovScoreVal = document.getElementById('ov-score-val');

  // Mobile keys container
  const mKeys = document.getElementById('mKeys');

  // Classic scoring (per lines)
  const LINE_TABLE = [0, 40, 100, 300, 1200];

  let board;
  let score = 0, lines = 0, level = 0;
  let dropCounter = 0, dropInterval = 1000;
  let lastTime = 0;
  let running = false;
  let nick = '';
  let piece = null;

  const TETROMINOES = {
    'T': [[0,1,0],[1,1,1],[0,0,0]],
    'O': [[1,1],[1,1]],
    'L': [[1,0,0],[1,1,1],[0,0,0]],
    'J': [[0,0,1],[1,1,1],[0,0,0]],
    'Z': [[1,1,0],[0,1,1],[0,0,0]],
    'S': [[0,1,1],[1,1,0],[0,0,0]],
    'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  };
  const TYPES = Object.keys(TETROMINOES);
  const COLORS = {
    0:'#0a1228',
    1:'#49b2ff', /* I */
    2:'#ffd86b', /* O */
    3:'#2ecc71', /* S */
    4:'#ff5666', /* Z */
    5:'#ff8ad6', /* T */
    6:'#8ad1ff', /* J */
    7:'#ffa552', /* L */
  };

  function createBoard(){ return Array.from({length: ROWS}, () => Array(COLS).fill(0)); }

  function updateHUD(){
    elScore.textContent = score.toLocaleString();
    elLines.textContent = lines;
    elLevel.textContent = (level+1);
  }

  function typeToColor(t){ return ({ I:1,O:2,S:3,Z:4,T:5,J:6,L:7 })[t]; }

  function collide(b, p){
    const m = p.matrix;
    for (let y=0; y<m.length; y++){
      for (let x=0; x<m[y].length; x++){
        if (!m[y][x]) continue;
        const ny = p.y + y, nx = p.x + x;
        if (ny < 0 || ny >= ROWS || nx < 0 || nx >= COLS || b[ny][nx]) return true;
      }
    }
    return false;
  }

  function merge(b, p){
    const m = p.matrix;
    for (let y=0; y<m.length; y++) for (let x=0; x<m[y].length; x++)
      if (m[y][x]) b[p.y+y][p.x+x] = p.color;
  }

  function rotate(matrix, dir=1){
    for (let y=0; y<matrix.length; y++)
      for (let x=0; x<y; x++)
        [matrix[x][y],matrix[y][x]] = [matrix[y][x],matrix[x][y]];
    if (dir>0) matrix.forEach(r=>r.reverse()); else matrix.reverse();
    return matrix;
  }

  function tryRotate(dir=1){
    const clone = piece.matrix.map(r=>r.slice());
    rotate(clone, dir);
    let offset = 0;
    while (collide(board, { ...piece, matrix:clone, x: piece.x + offset })){
      offset = offset ? -(offset + (offset>0?1:-1)) : 1;
      if (Math.abs(offset) > clone[0].length) return;
    }
    piece.matrix = clone; piece.x += offset;
  }

  function softDrop(){
    piece.y++;
    if (collide(board, piece)){
      piece.y--;
      lockPiece();
      return false;
    }else{
      score += 1; updateHUD(); return true;
    }
  }

  function hardDrop(){
    let dropped = 0;
    while (!collide(board, piece)){ piece.y++; dropped++; }
    piece.y--; dropped--;
    score += Math.max(0, dropped*2);
    lockPiece();
  }

  function move(dx){ piece.x += dx; if (collide(board, piece)) piece.x -= dx; }

  function sweep(){
    let cleared = 0;
    outer: for (let y=ROWS-1; y>=0; y--){
      for (let x=0; x<COLS; x++) if (!board[y][x]) continue outer;
      const row = board.splice(y,1)[0].fill(0); board.unshift(row); cleared++; y++;
    }
    lines += cleared; return cleared;
  }

  function setSpeedByLevel(){
    const table = [1000,900,800,700,600,500,450,400,350,300,260,220,200,180,160,140,120,100,90,80];
    dropInterval = table[Math.min(level, table.length-1)];
  }

  function lockPiece(){
    merge(board, piece);
    score += (level * 10);
    const cleared = sweep();
    if (cleared>0) score += LINE_TABLE[cleared]*(level+1);
    if (Math.floor(lines/10) > level){ level = Math.floor(lines/10); setSpeedByLevel(); }
    updateHUD();
    spawn();
  }

  function spawn(){
    const t = TYPES[(Math.random()*TYPES.length)|0];
    const matrix = TETROMINOES[t].map(r=>r.slice());
    piece = { x: ((COLS/2)|0) - ((matrix[0].length/2)|0), y:0, matrix, color:typeToColor(t) };
    if (collide(board, piece)){ gameOver(); }
  }

  function drawBlock(x,y,c){ ctx.fillStyle = COLORS[c]; ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK); ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.strokeRect(x*BLOCK+.5,y*BLOCK+.5,BLOCK-1,BLOCK-1); }

  function draw(){
    for (let y=0; y<ROWS; y++) for (let x=0; x<COLS; x++) drawBlock(x,y,board[y][x]);
    if (piece){
      const m = piece.matrix;
      for (let y=0; y<m.length; y++) for (let x=0; x<m[y].length; x++)
        if (m[y][x]) drawBlock(piece.x+x,piece.y+y,piece.color);
    }
  }

  function tick(t=0){
    if (!running) return;
    const dt = t - lastTime; lastTime = t;
    dropCounter += dt;
    if (dropCounter > dropInterval){ dropCounter = 0; softDrop(); }
    ctx.clearRect(0,0,canvas.width,canvas.height); draw();
    requestAnimationFrame(tick);
  }

  function gameOver(){
    running = false;
    showOverlay('over');         // GAME OVER 오버레이
  }

  /* ── Overlay 제어 ─────────────────────────────── */
  function showOverlay(mode='start'){
    if (mode === 'start'){
      ovTitle.textContent = '시작 / Restart';
      ovScoreWrap.style.display = 'none';
      btnStart.textContent = '게임 시작';
      btnStart.disabled = !(nickname.value.trim().length >= 2);
    }else{
      ovTitle.textContent = 'GAME OVER';
      ovScoreVal.textContent = score.toLocaleString();
      ovScoreWrap.style.display = 'block';
      btnStart.textContent = '게임 시작';
      btnStart.disabled = !(nickname.value.trim().length >= 2);
    }
    overlay.classList.remove('hide');
    overlay.hidden = false;
    overlay.style.display = 'flex';
    overlay.style.pointerEvents = 'auto';
    nickname.focus();
  }
  function hideOverlay(){
    overlay.hidden = true;
    overlay.classList.add('hide');
    overlay.style.display = 'none';
    overlay.style.pointerEvents = 'none';
  }

  /* ── Controls ─────────────────────────────────── */
  function keyHandler(e){
    if (!running) return;
    if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' '].includes(e.key)) e.preventDefault();
    switch(e.key){
      case 'ArrowLeft': move(-1); break;
      case 'ArrowRight': move(1); break;
      case 'ArrowDown': softDrop(); break;
      case 'ArrowUp': tryRotate(1); break;
      case ' ': case 'Spacebar': hardDrop(); break;
    }
    ctx.clearRect(0,0,canvas.width,canvas.height); draw();
  }
  window.addEventListener('keydown', keyHandler);

  // 모바일 키: 터치 디바이스면 항상 보임
  if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
    mKeys.classList.add('show');
  }
  document.querySelectorAll('.mkey').forEach(b=>{
    const k = b.dataset.key;
    const fire = ()=>{
      if (!running) return;
      if (k==='ArrowLeft') move(-1);
      else if (k==='ArrowRight') move(1);
      else if (k==='ArrowDown') softDrop();
      else if (k==='ArrowUp') tryRotate(1);
      else if (k==='Space') hardDrop();
      ctx.clearRect(0,0,canvas.width,canvas.height); draw();
    };
    b.addEventListener('touchstart', e=>{ e.preventDefault(); fire(); }, {passive:false});
    b.addEventListener('click', fire);
  });

  // 오버레이 입력/시작
  nickname.addEventListener('input', ()=>{ btnStart.disabled = !(nickname.value.trim().length >= 2); });

  btnStart.addEventListener('click', ()=>{
    const n = nickname.value.trim();
    if (n.length < 2) return;
    nick = n;
    hideOverlay();
    // 새 판 시작
    board = createBoard();
    score = 0; lines = 0; level = 0;
    updateHUD();
    setSpeedByLevel();
    spawn();
    dropCounter = 0; lastTime = 0;
    running = true;
    requestAnimationFrame(tick);
  });

  // 초기 상태: 시작 오버레이
  board = createBoard();
  updateHUD();
  showOverlay('start');
})();
</script>
</body>
</html>
